{"version":3,"sources":["../node_modules/prismjs/components/prism-cpp.js"],"names":["Prism","keyword","languages","cpp","extend","pattern","RegExp","source","replace","lookbehind","greedy","insertBefore","alias","inside"],"mappings":"iIAAA,SAAWA,GACT,IAAIC,EAAU,uqBACdD,EAAME,UAAUC,IAAMH,EAAME,UAAUE,OAAO,IAAK,CAChD,aAAc,CAAC,CACbC,QAASC,OAAO,gEAAgEC,OAAOC,QAAQ,cAAc,WAC3G,OAAOP,EAAQM,WAEjBE,YAAY,GAKd,iCAEA,oCAEA,gEACA,QAAWR,EACX,OAAU,CACRI,QAAS,qIACTK,QAAQ,GAEV,SAAY,qHACZ,QAAW,uBAEbV,EAAME,UAAUS,aAAa,MAAO,SAAU,CAC5C,aAAc,CACZN,QAAS,oCACTO,MAAO,SACPF,QAAQ,KAGZV,EAAME,UAAUS,aAAa,MAAO,aAAc,CAGhD,cAAe,CACbN,QAAS,6DACTI,YAAY,EACZC,QAAQ,EACRG,OAAQb,EAAME,UAAUE,OAAO,MAAO,OAG1CJ,EAAME,UAAUS,aAAa,SAAU,WAAY,CAEjD,aAAc,2BACbX,EAAME,UAAUC,IAAI,gBA7CzB,CA8CGH","file":"static/js/70.7f8a8ec8.chunk.js","sourcesContent":["(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+\\.?[\\da-f']*|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+\\.?[\\d']*|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]*/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:true|false)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)(?:[^;{}\"'])+?(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'operator', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(Prism);"],"sourceRoot":""}